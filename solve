#!/usr/bin/env node

// ------------------------------------------------------------------------
// solver cli
// ------------------------------------------------------------------------
const chalk = require('chalk');
const fs = require('fs');
const fse = require('fs-extra');
const glob = require('glob');
const sprintf = require('sprintf-js').sprintf;
const yargs = require('yargs');
const chokidar = require('chokidar');
const ora = require('ora');

let state = {
  spinner: undefined
};

class UsageError extends Error { }

function puzzleFolder(year, day) {
  return sprintf('src/%04d/%02d', year, day);
}

function puzzleTitle(year, day) {
  return sprintf('Year %04d Day %02d', year, day);
}


function solve(year, day, input) {
  let startTime = new Date().getTime();

  console.log('Solving ' + chalk.yellow(puzzleTitle(year, day)) + ' (input=' + input + ')');

  let lines = fs.readFileSync(input, 'utf8').split('\n');
  if (lines[lines.length - 1].length === 0) lines.pop();
  require(sprintf('./src/%04d/%02d', year, day))(lines);

  let endTime = new Date().getTime();
  console.log(sprintf('Finished (%07.4f seconds)', (endTime - startTime) / 1000));
}

function clearCache() {
  let re = new RegExp(process.cwd() + '/src');
  Object.keys(require.cache).filter(key => re.test(key)).forEach(key => {
    delete require.cache[key];
  });
}

function spin(enabled) {
  if (state.spinner) {
    state.spinner.stop();
    state.spinner = undefined;
  }
  if (enabled) {
    state.spinner = ora({ spinner: 'christmas', text: 'Waiting...' });
    state.spinner.start();
  }
}

function fileChanged(path) {
  let [year, day, file] = path.match(/^src\/(\d+)\/(\d+)\/(.+)/).slice(1);

  spin(false);
  clearCache();
  try {
    solve(year, day, `src/${year}/${day}/input.txt`);
  } catch (error) {
    console.log(chalk.red(error.stack));
  }
  spin(true);
}

function initPuzzle(year, day) {
  let folder = puzzleFolder(year, day);

  if (fse.existsSync(`${folder}/index.js`)) {
    throw new UsageError('Cannot initialize existing puzzle solution.');
  }

  fse.mkdirpSync(folder);
  fse.copyFileSync('src/template.js', `${folder}/index.js`);
  fse.writeFileSync(`${folder}/input.txt`, 'Happy Holidays!');
  console.log('Initialized puzzle for ' + chalk.yellow(puzzleTitle(year, day)));
}

function main() {
  const argv = yargs
    .boolean('init')
    .boolean('watch')
    .parse();

  let year = parseInt(argv._[0], 10);
  let day = parseInt(argv._[1], 10);
  let folder = puzzleFolder(year, day);
  let input = argv.input || `${folder}/input.txt`;

  if (!year || !day) {
    throw new UsageError('Usage: solve <year> <day> [--watch] [--input file.txt]');
  }

  if (argv.init) {
    initPuzzle(year, day);
  }

  if (!fs.existsSync(input)) {
    throw new UsageError('Invalid input file specified.');
  }

  solve(year, day, input);

  if (argv.watch) {
    const watcher = chokidar.watch('src');
    watcher.on('ready', () => {
      watcher.on('add', path => fileChanged(path));
      watcher.on('change', path => fileChanged(path));
      watcher.on('unlink', path => fileChanged(path));
      spin(true);
    });
  }
}

try {
  main();
} catch (error) {
  process.exitCode = 1;
  if (error instanceof UsageError) {
    console.error(chalk.red(error.message));
  } else {
    console.error(chalk.red(error.stack));
  }
}
